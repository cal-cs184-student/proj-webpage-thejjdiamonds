<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1.0, shrink-to-fit=no">
<link href="assets/images/diamond.png" rel="icon" />
<title>Project 3-1</title>
<meta name="description" content="184 Project 4 Writeup">
<meta name="author" content="harnishdesign.net">

<!-- Stylesheet
============================== -->
<!-- Bootstrap -->
<link rel="stylesheet" type="text/css" href="assets/vendor/bootstrap/css/bootstrap.min.css" />
<!-- Font Awesome Icon -->
<link rel="stylesheet" type="text/css" href="assets/vendor/font-awesome/css/all.min.css" />
<!-- Magnific Popup -->
<link rel="stylesheet" type="text/css" href="assets/vendor/magnific-popup/magnific-popup.min.css" />
<!-- Highlight Syntax -->
<link rel="stylesheet" type="text/css" href="assets/vendor/highlight.js/styles/github.css" />
<!-- Custom Stylesheet -->
<link rel="stylesheet" type="text/css" href="assets/css/stylesheet.css" />
</head>

<body data-spy="scroll" data-target=".idocs-navigation" data-offset="125">

<!-- Preloader -->
<div class="preloader">
  <div class="lds-ellipsis">
    <div></div>
    <div></div>
    <div></div>
    <div></div>
  </div>
</div>
<!-- Preloader End --> 

<!-- Document Wrapper   
=============================== -->
<div id="main-wrapper"> 
  
  <!-- Header
  ============================ -->
  <header id="header" class="sticky-top"> 
    <!-- Navbar -->
    <nav class="primary-menu navbar navbar-expand-lg navbar-dropdown-dark">
      <div class="container-fluid">
        <!-- Sidebar Toggler -->
		<button id="sidebarCollapse" class="navbar-toggler d-block d-md-none" type="button"><span></span><span class="w-75"></span><span class="w-50"></span></button>
		
		<!-- Logo --> 
        <!-- <a class="logo ml-md-3" href="index.html" title="iDocs Template"> <img src="assets/images/logo.png" alt="iDocs Template"/> </a>  -->
		<span class="text-2 ml-2">Jasmine Lin and Jennifer Prince</span> 
        <!-- Logo End -->
    </nav>
    <!-- Navbar End --> 
  </header>
  <!-- Header End --> 
  
  <!-- Content
  ============================ -->
  <div id="content" role="main">
    
	<!-- Sidebar Navigation
	============================ -->
	<div class="idocs-navigation bg-light">
      <ul class="nav flex-column ">
      	<li class="nav-item"><a class="nav-link" href="#overview_header">Project 4: Cloth Sim</a>
          <ul class="nav flex-column">
						<li class="nav-item"><a class="nav-link" href="#overview_content">Overview</a></li>
						<li class="nav-item"><a class="nav-link" href="#task1">Part 1: Masses and springs</a></li>
						<li class="nav-item"><a class="nav-link" href="#task2">Part 2: Simulation via numerical integration</a></li>
						<li class="nav-item"><a class="nav-link" href="#task3">Part 3: Handling collisions with other objects</a></li>
						<li class="nav-item"><a class="nav-link" href="#task4">Part 4: Handling self-collisions</a></li>
						<li class="nav-item"><a class="nav-link" href="#task5">Part 5: Shaders</a></li>
          </ul>
        </li>
        <li class="nav-item"><a class="nav-link" href="#website_link">Website Link</a>
        </li>
      </ul>
  </div>		
        
		<!-- <hr class="divider"> -->
		<!-- Docs Content
	============================ -->
    <div class="idocs-content">
      <div class="container"> 		
        
		<hr class="divider">

		<!-- Project 2 Header
		============================ -->
        <section id="overview_header">
          <h1>Project 4: Cloth Sim</h1>
          <div id="centerImage">
          	<!-- <p><img src="images/cow.PNG" alt="cow mesh" width="800px" align="middle"/></p> -->
          	<p><img src="images/spec.jpg" alt="bunnies" width="900px" align="middle"/></p>
        	</div>
        </section>

    <hr class="divider">
		
		<!-- Overview
		============================ -->
        <section id="overview_content">
          <h2>Overview</h2>
          <p class="lead mb-5">REPLACE OVERVIEW</p>
        </section>

    <hr class="divider">

    <!-- Section 1 Header
		============================ -->
       <!--  <section id="section1_header">
          <h1>Section I: Bezier Curves and Surfaces</h1>
        </section> -->

        <!-- Task 1 Content
		============================ -->
        <section id="task1">
          <h2>Part 1: Masses and springs</h2>
		<p> 
			In this part, we implemented <code>Cloth::buildGrid</code> to create arrays of point masses and springs to represent the cloth in our simulation. We evenly distributed point masses over the width and height of the given cloth, and then created springs between appropriate point masses as described in the spec.
		</p>
		<p>
			Here are some screenshots of <code>scene/pinned2.json</code>, where you can see the wireframe representing the point masses and springs that simulate the cloth.
		</p>
	
		  <div id="centerImage">
			<img src="images/part1/pinned21.png" width="800px" style="margin: 5px 5px 5px 5px;">
			<figcaption>scene/pinned2.json</figcaption>	
		  </div>
		
		<p>
			Here is the wireframe without any shearing constraints:
		</p>

		  <div id="centerImage">
			<img src="images/part1/noshear.png" width="800px" style="margin: 5px 5px 5px 5px;">
			<figcaption>no shearing constraints</figcaption>	
		  </div>

		<p>
			Here is the wireframe with only shearing constraints:
		</p>

		  <div id="centerImage">
			<img src="images/part1/onlyshear.png" width="800px" style="margin: 5px 5px 5px 5px;">
			<figcaption>only shearing constraints</figcaption>	
		  </div>

		<p>
			Here is the wireframe again with all the constraints:
		</p>

		  <div id="centerImage">
			<img src="images/part1/all.png" width="800px" style="margin: 5px 5px 5px 5px;">
			<figcaption>all constraints</figcaption>	
		  </div>


       <hr class="divider">
		
		<!-- Task 2 Content
		============================ -->
        <section id="task2">
          <h2>Part 2: Simulation via numerical integration</h2>
      <p>A Bounding Volume Hierarchy (BVH) acceleration structure is used to organize objects in a scene for the purpose of speeding up ray-object intersection tests. It starts by dividing the scene into a hierarchy of bounding boxes, and subdivides them recursively until each leaf node contains only a small number of primitives. When a ray is cast into the scene, it is tested against the bounding volumes at each level of the hierarchy, which enables the renderer to quickly eliminate large groups of objects that the ray does not intersect. This leads to a significant reduction in the number of intersection tests that need to be performed, resulting in faster rendering times.</p>
		  <p>
			Our BVH construction algorithm recursively creates each node in the BVH according to the <code>max_leaf_size</code> passed in and our splitting point heuristic. The process is as follows:
			</p>
			<p>
			<ul>
				<li>First, we compute the bounding box of the entire list of primitives passed in (from the iterators <code>start</code> to <code>end</code>) and initialize a new BVHNode <code>node</code> with that bounding box.</li>
				<li>If the number of primitives in this bounding box is less than or equal to <code>max_leaf_size</code>, we simply set this new node’s <code>start</code> and <code>end</code> iterators to be the same as the ones passed in, and return node. This is our base case.</li>
				<li>Otherwise, we must start the process of splitting the primitives into two parts and creating a BVHNode for the left and right children recursively.</li>
				<ul>
					<li>Our splitting heuristic was to choose the longest axis of the current bounding box that all the primitives lie in, then split the primitives based on which half of this axis they lie on.</li>
					<li>We made a lambda function that would take in a primitive and return true if its centroid lay to the left of the midpoint of the longest bounding box axis, and false otherwise.</li>
					<li>We passed this lambda function into <code>std::partition</code>, which would sort the list in-place based on this function. It returns an iterator which we called <code>mid</code> that points to the part of the list where the primitives stop landing on one side of the axis and belong to the other.</li>
					<li>Finally, we simply made the two recursive calls to <code>BVHAccel::construct_bvh</code> on the left and right members of node, passing in the iterators <code>start</code> and <code>mid</code> for the left child, and the iterators <code>mid</code> and <code>end</code> for the right child.</li>
				</ul>
				<li>Our splitting scheme has a chance of choosing a split point such that all primitives lie on only one side of the split point. To avoid the infinite recursion of this case, we made an extra check through the iterators after <code>std::partition</code> is called to see if any part of the list has zero primitives. If we found that this was the case, we simply divided the remaining list of primitives in half, set the <code>mid</code> iterator to the middle of this list, and proceeded to the recursive calls.</li>
			</ul>
			</p>
			<p>
				After completing <code>BVHAccel::has_intersection</code> and <code>BVHAccel::intersect</code>, the following large .dae files can render in a fraction of a second:
			</p>
			<div class="row">
				<div class="column">
				  <img src="images/bunny.png" width="480px" style="margin: 5px 5px 5px 5px;">
				  <figcaption>dae/sky/CBbunny.dae</figcaption>
				</div>
				<div class="column">
				  <img src="images/lucy.png" width="480px" style="margin: 5px 5px 5px 5px;">
				  <figcaption>dae/sky/CBlucy.dae</figcaption>
				</div>
				<div class="column">
				  <img src="images/planck.png" width="800px" style="margin: 5px 5px 5px 5px;">
				  <figcaption>dae/meshedit/maxplanck.dae</figcaption>
				</div>
			  </div>
			<p>
				Let us take a look at <code>dae/meshedit/cow.dae</code>, <code>dae/sky/bench.dae</code>, and <code>dae/sky/CBcoil.dae</code> to see how BVH acceleration helps render times increase. The cow took 0.1789s, the bench took 0.0539s, and the coil took 0.0680s to render with BVH. Without the BVH acceleration implemented, the cow took 40.1128s, the bench took 277.2048s, and the coil took 39.2773s! As you can see with these rendering times, Bounding Volume Hierarchies greatly enhanced the speed at which we can calculate ray-object intersections using recursion and good heuristics for partitioning objects into bounded boxes.
			</p>
			<div class="row">
				<div class="column">
				  <img src="images/cow.png" width="360px" style="margin: 5px 5px 5px 5px;">
				  <figcaption>cow</figcaption>
				</div>
				<div class="column">
				  <img src="images/bench.png" width="360px" style="margin: 5px 5px 5px 5px;">
				  <figcaption>bench</figcaption>
				</div>
				<div class="column">
				  <img src="images/coil.png" width="360px" style="margin: 5px 5px 5px 5px;">
				  <figcaption>coil</figcaption>
				</div>
			  </div>
		</section>

		<hr class="divider">

		<!-- Section 2 Header
		============================ -->
       <!--  <section id="section2_header">
          <h1>Section II: Triangle Meshes and Half-Edge Data Structure</h1>
        </section> -->
		
		<!-- Task 3 Content
		============================ -->
        <section id="task3">
        <h2>Part 3: Handling collisions with other objects</h2>
		<p>To support cloth collision, we wrote an implementation that would support cloth collision with a sphere and cloth collision with a plane.</p>
		<p>
			For sphere collision, we first check whether the point mass is in the sphere, which is done based on its distance from the center of the sphere. If the distance was less than the sphere’s radius, then the position of the point mass was located inside the sphere. 
			From there, we calculated the tangent point (if we extended the path between the point mass’s position and the sphere’s origin to the sphere’s surface, the intersection with the sphere’s surface would be the tangent point). The tangent point was calculated by finding 
			the direction between the point mass and origin and then multiplying it by the radius. We then added that result to the origin (effectively extending to the sphere’s surface). We then computed the correction vector, which was the difference between the tangent point and <code>pm.last_position</code>. 
			Finally, <code>pm.position</code> was updated with <code>pm.last_position + correction_vector * (1 - this->friction)</code>. 
		</p>
		<p>
			Below, we can see the images of the cloth’s resting position at varying values of ks. At <code>ks = 5000</code>, we see the default value of <code>ks</code>. The differences are more apparent when compared to <code>ks = 500</code> and <code>ks = 50000</code>. At 500, the cloth over the sphere droops 
			down a bit more (where it appears that the cloth is more weighted down than the default value of <code>ks</code>). At 50000, the cloth is more “inflated” than the default value of <code>ks</code>, and appears to be more elevated (in other words, droops less over the sphere). 
		</p>
		<div class="row centerImage">
			<div class="column">
			  <img src="images/part3/ks500.png" width="330px" style="margin: 5px 5px 5px 5px;">
			  <figcaption> ks = 500 </figcaption>
			</div>
			<div class="column">
			  <img src="images/part3/ks5000.png" width="330px" style="margin: 5px 5px 5px 5px;">
			  <figcaption> ks = 5000</figcaption>
			</div>
			<div class="column">
				<img src="images/part3/ks50000.png" width="330px" style="margin: 5px 5px 5px 5px;">
				<figcaption> ks = 500000 </figcaption>
			  </div>
		  </div>
		  <p>
			For plane collision, it’s a similar process to the sphere collision. In this case, we want to check if the point mass moved from one side of the plane to the other. In other words, we want to check if the point mass intersected with the plane based on <code>pm.position</code> and <code>pm.last_position</code>. 
			For those variables, we found their difference with the point on the plane. Taking those differences, we found their dot product with the plane’s normal respectively to determine which side of the plane they were on - if the dot products had opposite signs, it implied that an intersection with the plane did occur. 
			We then calculated the tangent point based on the position of the point mass, the plane’s normal and the dot product between the plane’s normal and <code>pm.position - this->point</code> (point on the plane). The correction_vector was based on the difference between the tangent point and <code>pm.last_position</code> 
			with the addition of a surface offset to account for a slight displacement above the tangent point. Finally, <code>pm.position</code> was updated the same as was done in the sphere. 
		  </p>

		  <p>Below is an image of the shaded cloth laying on the plane: </p>
		  	
		  <div id="centerImage">
			<img src="images/part3/plane_rest.png" width="800px" style="margin: 5px 5px 5px 5px;">
			<figcaption>Cloth laying (peacefully) on the plane</figcaption>	
		  </div>
			
		
        <hr class="divider">

        <!-- Task 4 Content
		============================ -->
        <section id="task4">
          <h2>Part 4: Handling self-collisions</h2>
          <p>In our implementation of indirect lighting function, we first implemented the function <code>sample_f</code> that would help us take a sample for the function <code>at_least_one_bounce_radiance</code>. In this function, we considered the case of when <code>max_ray_depth = 0</code> and when <code>max_ray_depth = 1</code>. In the former situation, 
			we would return zero bounce illumination; in the latter case, we would return one bounce illumination. This was to account for the cases where we would only have direct illumination. So, specifically for indirect illumination, when <code>max_ray_depth</code> was greater than 1, we wanted to ensure that we always did at least 1 indirect bounce and 
			that once that bounce was done, Russian Roulette would account for whether we would terminate on a certain bounce. To account for both cases, we had two checks in our code. For our first check: if the current ray’s depth was equal to the max ray depth, that implied that we haven’t had 1 indirect bounce yet (and this is assuming that <code>max_ray_depth</code> 
			is greater than 1). For our second check, we set our termination probability to 0.35 (so the probability of the algorithm continuing would be 0.65), and we used the <code>coin_flip</code> function to determine if Russian Roulette would terminate the process. Assuming that the process wasn’t terminated, we casted our ray and decremented the ray’s depth and then 
			checked its intersection with our bvh. If it intersected, then we recursively called on <code>at_least_one_bounce_radiance</code> and the recursive result was factored into <code>L_out</code>. More specifically, the recursive result was multiplied by our sample from <code>sample_f</code> and the derived cosine factor and then divided by the pdf and the probability 
			of continuation. 
		</p>
		<p>
			To show what it looks like, we rendered two images as shown below using our implementation of global illumination: 
		</p>

		<div class="row">
			<div class="column">
			  <img src="images/bunny_global.png" width="480px" style="margin: 5px 5px 5px 5px;">
			  <figcaption> CBbunny.dae with Global Illumination </figcaption>
			</div>
			<div class="column">
			  <img src="images/dragon_global.png" width="480px" style="margin: 5px 5px 5px 5px;">
			  <figcaption> dragon.dae with Global Illumination </figcaption>
			</div>
		  </div>

		  <p>
			To see what direct and indirect lighting look like, we rendered CBbunny.dae with both types of lighting. 
		  </p>

		  <div class="row">
			<div class="column">
			  <img src="images/bunny_direct.png" width="480px" style="margin: 5px 5px 5px 5px;">
			  <figcaption> CBbunny.dae with Direct Lighting </figcaption>
			</div>
			<div class="column">
			  <img src="images/bunny_indirect.png" width="480px" style="margin: 5px 5px 5px 5px;">
			  <figcaption> CBbunny.dae with Indirect Lighting </figcaption>
			</div>
		  </div>

		  <p>Between the two, rendering with direct lighting creates a harsher contrast with lighting - more specifically, the shadows are more harsh and more apparent on the bunny's body. In addition, the ceiling is mostly dark, with only the ceiling lighting lit up. 
			In comparison, indirect lighting creates a softer look, where the shadows aren't as apparent and the ceiling is completely lit up (the shadows are much less distinguishable than they are with just direct lighting). If comparing both images though with the one 
			above it, specifically with global illumination, both images are "darker" or "dimmer" than their global illumination counterpart. 
		  </p>

		  <p>
			We then rendered some sceens with varying levels of max ray depth. 
		  </p>
			<div class="row">
				<div class="column">
				<img src="images/task4_max_ray_depth/bunny_ray_0.png" width="480px" style="margin: 5px 5px 5px 5px;">
				<figcaption> Max Ray Depth of 0 </figcaption>
				</div>
				<div class="column">
				<img src="images/task4_max_ray_depth/bunny_ray_1.png" width="480px" style="margin: 5px 5px 5px 5px;">
				<figcaption> Max Ray Depth of 1</figcaption>
				</div>
			</div>
			<div class="row">
				<div class="column">
				<img src="images/task4_max_ray_depth/bunny_ray_2.png" width="480px" style="margin: 5px 5px 5px 5px;">
				<figcaption> Max Ray Depth of 2 </figcaption>
				</div>
				<div class="column">
				<img src="images/task4_max_ray_depth/bunny_ray_3.png" width="480px" style="margin: 5px 5px 5px 5px;">
				<figcaption> Max Ray Depth of 3 </figcaption>
				</div>
			</div>
			<div class="row">
				<div class="column">
				<img src="images/task4_max_ray_depth/bunny_ray_depth100.png" width="480px" style="margin: 5px 5px 5px 5px;">
				<figcaption> Max Ray Depth of 100 </figcaption>
				</div>
			</div>
			<p>
				Comparing the CBbunny.dae renders at different settings of max ray depth, the most noticeable difference comes from the jump between 1 and 2. At max ray depth of 0, it is only a black screen with the light on top; at max ray depth of 1, the bunny starts to show up 
				but it is still relatively dark, with some harsh shadows on the bottom portion of the bunny and with the ceiling still mostly dark with the exception of the ceiling light. At max ray depth of 2, the ceiling is completely lit up and the bunny's shadow becomes softer. 
				As we increase the max ray depth, the changes becomes less discernable, and it doesn't appear that the image changes too much in regards to lighting and shadows. 
			</p>
			
          <p>Now, below are the scenes rendered with various sample-per-pixel rates (using 4 light rays):</p>
          <div class="row">
					<div class="column">
					  <img src="images/bunny_1.png" width="480px" style="margin: 5px 5px 5px 5px;">
					  <figcaption>1 sample per pixel</figcaption>
					</div>
					<div class="column">
					  <img src="images/bunny_2.png" width="480px" style="margin: 5px 5px 5px 5px;">
					  <figcaption>2 samples per pixel</figcaption>
					</div>
				  </div>
				  <div class="row">
					<div class="column">
					  <img src="images/bunny_4.png" width="480px" style="margin: 5px 5px 5px 5px;">
					  <figcaption>4 samples per pixel</figcaption>
					</div>
					<div class="column">
					  <img src="images/bunny_8.png" width="480px" style="margin: 5px 5px 5px 5px;">
					  <figcaption>8 samples per pixel</figcaption>
					</div>
				  </div>
				  <div class="row">
					<div class="column">
					  <img src="images/bunny_16.png" width="480px" style="margin: 5px 5px 5px 5px;">
					  <figcaption>16 samples per pixel</figcaption>
					</div>
					<div class="column">
					  <img src="images/bunny_32.png" width="480px" style="margin: 5px 5px 5px 5px;">
					  <figcaption>32 samples per pixel</figcaption>
					</div>
				  </div>
				  <div class="row">
					<div class="column">
					  <img src="images/bunny_64.png" width="480px" style="margin: 5px 5px 5px 5px;">
					  <figcaption>64 samples per pixel</figcaption>
					</div>
					<div class="column">
					  <img src="images/bunny_1024.png" width="480px" style="margin: 5px 5px 5px 5px;">
					  <figcaption>1024 samples per pixel</figcaption>
					</div>
				  </div>
				  <p> Most noticeably from all these scenes is that the more the sampling per pixel rate increases, the more clear the image becomes. In other words, sampling at a lower rate means there is much more noise in the image; the more that we increase the sampling
					rate, the less noisy the images becomes and it starts to appear more smooth. 
				 </p>

        <hr class="divider">
		
		<!-- Task 5 Content
		============================ -->
        <section id="task5">
          <h2>Part 5: Shaders</h2>
		  <p> A shader program, in a very basic sense, takes in an input and returns an output - in the case of the graphics pipeline, it mainly handles determining the appropriate lighting, 
			color and darkness when rendering a scene. For this project, the information outputted ends up being stored in a <code>vec4</code> and might include information like displacement. 
			Vertex shader applies transformation to vertices and can change properties like their position. Fragment shaders generally take in certain attributes to write out a color. Combined, 
			they can help produce specific lighting and material effects by modifying the appropriate inputs for the mentioned shaders above. 
		</p>
		<p>
			The Blinn-Phong model accounts for different types of lighting, specifically, it accounts for ambient lighting, diffuse lighting and specular lighting. Ambient lighting can be thought 
			of as “constant” lighting or available lighting (hence the term in the equation in the spec). Diffuse lighting is part of the light that bounces off an object and ends up scattering or 
			diffusing in several directions. Specular lighting refers to the specular highlights that can be found of objects (otherwise known as the “glossy” part of an object) and occurs when a 
			light hits the surface of an object. 
		</p>
		<p>
			Below are images that reference each component of the Blinn-Phong shading model as well as the full model itself: 
		</p>

		  <div class="row">
			<div class="column">
			  <img src="images/part5/ambient.png" width="480px" style="margin: 5px 5px 5px 5px;">
			  <figcaption>Ambient component only (<code>ka = 0.1</code>)</figcaption>
			</div>
			<div class="column">
			  <img src="images/part5/diffuse.png" width="480px" style="margin: 5px 5px 5px 5px;">
			  <figcaption>Diffuse component only</figcaption>
			</div>
		  </div>
		  <div class="row">
			<div class="column">
			  <img src="images/part5/specular.png" width="480px" style="margin: 5px 5px 5px 5px;">
			  <figcaption>Specular component only</figcaption>
			</div>
			<div class="column">
			  <img src="images/part5/full_blinn_phong.png" width="480px" style="margin: 5px 5px 5px 5px;">
			  <figcaption>Full Blinn-Phong model</figcaption>
			</div>
		  </div>

		  <p>
			For the texture mapping shader, we used the built-in function <code>texture(sampler2D tex, vec2 uv)</code>, that took in a texture and space coordinate, 
			to sample from our texture map. 
		  </p>
		  <div class="row">
			<div class="column">
			  <img src="images/part5/custom_texture_1.png" width="450px" style="margin: 5px 5px 5px 5px;">
			  <figcaption>Custom texture mapping before cloth falls</figcaption>
			</div>
			<div class="column">
			  <img src="images/part5/custom_texture_2.png" width="450px" style="margin: 5px 5px 5px 5px;">
			  <figcaption>Custom texture mapping after cloth falls</figcaption>
			</div>
		  </div>

		  <p>
			For bump shading, we first computed the bitangent vector and then created a 3-d matrix made up of the tangent vector, bitangent vector and normal vector. We then computed the local 
			space normal, which helped us find the displaced model space normal. Similar to what we did in Blinn-Phong shading, instead of using the vector normal though, we used the displaced 
			model space normal that we found when calculating the lighting. 
		  </p>
		  <p>
			For displacement modeling, we did something similar and used the same implementation for bump shading in our displacement fragment shader. The main difference was that we modified the 
			displacement vector shader - for this portion, we wanted to displace our vertex position in the direction of the original model space and scale it according to the height scaling factor. 
			Once this was computed and we had a vector, we set <code>gl_Postition</code> to a product of that vector and <code>u_view_projection</code>. 
		  </p>

		  <p>
			Below are the images for bump and displacement mapping: 
		  </p>

		  <div class="row">
			<div class="column">
			  <img src="images/part5/bump_sphere.png" width="480px" style="margin: 5px 5px 5px 5px;">
			  <figcaption>Bump mapping on sphere</figcaption>
			</div>
			<div class="column">
			  <img src="images/part5/bump_cloth.png" width="480px" style="margin: 5px 5px 5px 5px;">
			  <figcaption>Bump mapping on cloth</figcaption>
			</div>
		  </div>

		  <div class="row">
			<div class="column">
			  <img src="images/part5/displacement_sphere.png" width="480px" style="margin: 5px 5px 5px 5px;">
			  <figcaption>Displacement mapping on sphere</figcaption>
			</div>
			<div class="column">
			  <img src="images/part5/displacement_cloth.png" width="480px" style="margin: 5px 5px 5px 5px;">
			  <figcaption>Displacement mapping on cloth</figcaption>
			</div>
		  </div>

		  <p>
			Looking at both renders, there is a noticeable difference in the geometry of the objects. Specifically speaking, looking at bump mapping, the geometry of the sphere and cloth aren’t really affected, 
			but we’ll notice that ridges and bumps on the outer edge of the sphere and cloth for displacement mapping start to appear. From our implementation, bump mapping modifies the texture or fragment shader, 
			while for displacement, we end up modifying the vector shader, which results in the change of geometry for the sphere and cloth (i.e. it also modifies the vectors). 
		  </p>
		  
		  <p>
			We then render with varying levels of coarseness: 
		  </p>

		  <div class="row">
			<div class="column">
			  <img src="images/part5/bump_16.png" width="480px" style="margin: 5px 5px 5px 5px;">
			  <figcaption>Bump mapping with -o 16 -a 16</figcaption>
			</div>
			<div class="column">
			  <img src="images/part5/displacement_16.png" width="480px" style="margin: 5px 5px 5px 5px;">
			  <figcaption>Displacement mapping with -o 16 -a 16</figcaption>
			</div>
		  </div>
		  <div class="row">
			<div class="column">
			  <img src="images/part5/bump_128.png" width="480px" style="margin: 5px 5px 5px 5px;">
			  <figcaption>Bump mapping with -o 128 -a 128</figcaption>
			</div>
			<div class="column">
			  <img src="images/part5/displacement_128.png" width="480px" style="margin: 5px 5px 5px 5px;">
			  <figcaption>Displacement mapping with -o 128 -a 128</figcaption>
			</div>
		  </div>
		  <p>
			At coarseness 16, we note that render produced with displacement mapping is slightly inaccurate in the sense that there are still uneven ridges around the sphere’s outline, as opposed to bump mapping where the 
			edges of the sphere appear more smoothed out. At higher levels though, while bump mapping still produces an accurate render, displacement mapping leads to a more accurate image where the geometry of the sphere more
			closely resembles the expected shape of a sphere. 
		  </p>

		  <p>
			For the mirror shader and taking <code>u_cam_pos</code> (camera’s position) and <code>v_position</code> (fragment’s position), we computed the outgoing ray 
			and then reflected it across the surface normal in <code>v_normal</code>. The resulting reflected vector was then passed into the built-in function <code>texture</code>.
		  </p>

		  <div class="row">
			<div class="column">
			  <img src="images/part5/sphere_reflection.png" width="468px" style="margin: 5px 5px 5px 5px;">
			  <figcaption>Reflection on the sphere</figcaption>
			</div>
			<div class="column">
			  <img src="images/part5/cloth_reflection.png" width="450px" style="margin: 5px 5px 5px 5px;">
			  <figcaption>Reflection on the cloth</figcaption>
			</div>
		  </div>

    <hr class="divider">

    <!-- Website Link -->
        <section id="website_link">
        	<p>Here is the link to this website: <a href="https://cal-cs184-student.github.io/proj-webpage-thejjdiamonds/proj4/index.html" > link</a></p>
        	<p><a href="https://cal-cs184-student.github.io/proj-webpage-thejjdiamonds/proj4/index.html">https://cal-cs184-student.github.io/proj-webpage-thejjdiamonds/proj4/index.html</a></p>
        </section>
		  
  
</div>
<!-- Document Wrapper end --> 

<!-- Back To Top --> 
<a id="back-to-top" data-toggle="tooltip" title="Back to Top" href="javascript:void(0)"><i class="fa fa-chevron-up"></i></a> 

<!-- JavaScript
============================ -->
<script src="assets/vendor/jquery/jquery.min.js"></script> 
<script src="assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script> 
<!-- Highlight JS -->
<script src="assets/vendor/highlight.js/highlight.min.js"></script> 
<!-- Easing --> 
<script src="assets/vendor/jquery.easing/jquery.easing.min.js"></script> 
<!-- Magnific Popup --> 
<script src="assets/vendor/magnific-popup/jquery.magnific-popup.min.js"></script> 
<!-- Custom Script -->
<script src="assets/js/theme.js"></script>
</body>
</html>
